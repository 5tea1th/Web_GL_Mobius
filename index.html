<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Möbius Strip</title>
    <style>
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            margin: 0;
        }
        #exportButton {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</head>
<body>
    <button id="exportButton">Export STL</button>
    <canvas id="glcanvas"></canvas>
    <script type="text/javascript">
        function main() {
            const canvas = document.getElementById("glcanvas");
            const gl = canvas.getContext("webgl");

            if (!gl) {
                alert("Unable to initialize WebGL. Your browser may not support it.");
                return;
            }
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height); // Set the viewport

            // Shader sources
            const vertexShaderSource = `
                attribute vec4 aVertexPosition;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                void main(void) {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                }
            `;
            const fragmentShaderSource = `
                void main(void) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); 
                    // Black color for the Möbius strip
                }
            `;

            // Compile shaders
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);

            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(vertexShader));
                return null;
            }
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(fragmentShader));
                return null;
            }

            // Create and link program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }

            // Buffer setup
            const positions = [];
            const segments = 200; // Increased segments for higher resolution

            for (let i = 0; i <= segments; i++) {
                const t = i / segments * 2 * Math.PI;
                for (let j = 0; j < 2; j++) {
                    const s = j === 0 ? -1 : 1;
                    const x = Math.cos(t) * (1 + 0.5 * s * Math.cos(t / 2));
                    const y = Math.sin(t) * (1 + 0.5 * s * Math.cos(t / 2));
                    const z = 0.5 * s * Math.sin(t / 2);
                    positions.push(x, y, z);
                }
            }


        }

    </script>
      


</body>
</html>
